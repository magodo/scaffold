// +build ignore

// This program generate a go file (template.go) base on the *template* folder, used to generate scaffold from template.
// The output go file path is at the same directory as the invoking go file (which contains the "//go generate" directives).
//
// It accepts following arguments:
// - tempalte dir
package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"text/template"
)

var outputTemplate string

type TemplateEntries struct {
	// value is path
	Dirs []string
	// key is path, value is content
	Files map[string]string
}

type Engine struct {
	rootDir        string
	InvokerPackage string
	TemplateEntries
}

func main() {
	const outputTemplateGoPath = "template.go"
	templateDir := os.Args[1]

	// ensure templateDir is available
	if err := os.MkdirAll(templateDir, os.ModePerm); err != nil {
		log.Fatal(err)
	}

	invokerPackage := os.Getenv("GOPACKAGE")

	engine := newEngine(templateDir, invokerPackage)
	if err := filepath.Walk(templateDir, engine.visit); err != nil {
		log.Fatal(err)
	}

	// generate template go file in current directory
	f, err := os.Create(outputTemplateGoPath)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	template.Must(template.New("").Parse(outputTemplate)).Execute(f, engine)
}

func newEngine(root string, invokerPkg string) *Engine {
	return &Engine{
		rootDir:        root,
		InvokerPackage: invokerPkg,
		TemplateEntries: TemplateEntries{
			Files: make(map[string]string),
		},
	}
}

func (e *Engine) visit(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err
	}
	return e.addTemplateEntry(path, info)
}

func (e *Engine) addTemplateEntry(path string, info os.FileInfo) error {
	templateRelPath, err := filepath.Rel(e.rootDir, path)
	if err != nil {
		return err
	}
	if info.IsDir() {
		subEntries, err := ioutil.ReadDir(path)
		if err != nil {
			return err
		}
		// only add deepest empty dir
		if len(subEntries) == 0 {
			e.TemplateEntries.Dirs = append(e.TemplateEntries.Dirs, templateRelPath)
		}
		return nil
	}

	content, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}
	e.TemplateEntries.Files[templateRelPath] = string(content)
	return nil
}

func init() {
	outputTemplate = fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.
package {{ .InvokerPackage }}

import (
	"os"
	"text/template"
	"path/filepath"
)

var (
	templateDirs = []string{
	{{- range .TemplateEntries.Dirs }}
		"{{.}}",
	{{- end }}
	}

	templateFiles = map[string]string{
	{{ range $key, $value := .TemplateEntries.Files }}
		"{{ $key }}": %s,
	{{- end }}
	}
)

func GenScaffold(outdir string, data interface{}) error {
	for _, dir := range templateDirs {
		dir = filepath.Join(outdir, dir)
		if err := os.MkdirAll(dir, os.ModePerm); err != nil {
			return err
		}
	}

	for path, content := range templateFiles {
		path = filepath.Join(outdir, path)
		dir := filepath.Dir(path)
		if err := os.MkdirAll(dir, os.ModePerm); err != nil {
			return err
		}
		f, err := os.Create(path)
		if err != nil {
			return err
		}
		defer f.Close()

		t, err := template.New("").Parse(content)
		if err != nil {
			return err
		}
		if err := t.Execute(f, data); err != nil {
			return err
		}
	}

	return nil
}`, "`{{ $value }}`")
}
